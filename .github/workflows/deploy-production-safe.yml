name: Safe Production Deployment

# This workflow ensures bad code NEVER reaches the Pi
# All validation happens on GitHub-hosted runners BEFORE any Pi interaction

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip some checks)'
        type: boolean
        default: false
      environment:
        description: 'Deployment environment'
        type: choice
        options:
          - production
          - staging
        default: production

# Prevent concurrent deployments
concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  # ============================================================================
  # PHASE 1: PRE-FLIGHT VALIDATION (GitHub-hosted)
  # These checks MUST pass before ANYTHING touches the Pi
  # ============================================================================
  
  pre-flight-checks:
    name: Pre-flight Safety Checks
    runs-on: ubuntu-latest
    outputs:
      can_deploy: ${{ steps.decision.outputs.can_deploy }}
      validation_score: ${{ steps.score.outputs.score }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for secrets in code
        id: secrets
        run: |
          echo "üîç Scanning for exposed secrets..."
          
          # Install and run multiple secret scanners
          pip install truffleHog3
          trufflehog3 --no-history --format json --output secrets-report.json || true
          
          # Also use gitleaks
          wget -q https://github.com/gitleaks/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz
          tar -xzf gitleaks_8.18.0_linux_x64.tar.gz
          ./gitleaks detect --no-git --verbose --report-format json --report-path gitleaks-report.json || true
          
          # Check if any secrets were found
          if [ -s secrets-report.json ] || [ -s gitleaks-report.json ]; then
            echo "‚ùå SECRETS DETECTED - BLOCKING DEPLOYMENT"
            echo "::error::Secrets detected in code. Deployment blocked for security."
            exit 1
          fi
          echo "‚úÖ No secrets detected"

      - name: Validate configuration files
        id: config
        run: |
          echo "üìã Validating all configuration files..."
          
          # Check docker-compose files
          for file in docker-compose*.yml; do
            if [ -f "$file" ]; then
              echo "Validating $file..."
              docker compose -f "$file" config > /dev/null || {
                echo "‚ùå Invalid docker-compose file: $file"
                exit 1
              }
            fi
          done
          
          # Validate .env.example
          if [ -f .env.example ]; then
            echo "Checking .env.example for required variables..."
            required_vars="MINIO_ENDPOINT MINIO_ACCESS_KEY DISCORD_WEBHOOK_URL"
            for var in $required_vars; do
              if ! grep -q "^$var=" .env.example; then
                echo "‚ùå Missing required variable: $var"
                exit 1
              fi
            done
          fi
          
          echo "‚úÖ All configuration files valid"

      - name: Check for syntax errors
        id: syntax
        run: |
          echo "üîß Checking for syntax errors..."
          
          # Check Go syntax
          if [ -d "backend" ]; then
            cd backend
            echo "Checking Go syntax..."
            gofmt -l . > ../go-format-issues.txt
            if [ -s ../go-format-issues.txt ]; then
              echo "‚ùå Go formatting issues found:"
              cat ../go-format-issues.txt
              exit 1
            fi
            go mod tidy
            git diff --exit-code go.mod go.sum || {
              echo "‚ùå go.mod/go.sum not tidy"
              exit 1
            }
            cd ..
          fi
          
          # Check Python syntax
          if [ -d "pi-processor" ]; then
            echo "Checking Python syntax..."
            python3 -m py_compile pi-processor/*.py || {
              echo "‚ùå Python syntax errors found"
              exit 1
            }
          fi
          
          # Check JavaScript/TypeScript
          if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
            cd frontend
            echo "Checking TypeScript syntax..."
            npm ci
            npm run type-check || {
              echo "‚ùå TypeScript errors found"
              exit 1
            }
            cd ..
          fi
          
          echo "‚úÖ No syntax errors found"

      - name: Calculate validation score
        id: score
        run: |
          echo "üìä Calculating validation score..."
          score=100
          
          # Deduct points for warnings
          if [ -f "warnings.log" ]; then
            warnings=$(wc -l < warnings.log)
            score=$((score - warnings))
          fi
          
          echo "score=$score" >> $GITHUB_OUTPUT
          echo "Validation score: $score/100"
          
          if [ $score -lt 80 ]; then
            echo "‚ö†Ô∏è Validation score too low: $score/100"
            echo "Minimum required: 80/100"
            exit 1
          fi

      - name: Deployment decision
        id: decision
        run: |
          echo "üéØ Making deployment decision..."
          
          # Check if this is a forced deployment
          if [ "${{ inputs.force_deploy }}" = "true" ]; then
            echo "‚ö†Ô∏è Forced deployment requested"
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "can_deploy=true" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Pre-flight checks passed - safe to proceed"

  # ============================================================================
  # PHASE 2: BUILD VALIDATION (GitHub-hosted)
  # Ensure code actually builds before attempting deployment
  # ============================================================================
  
  build-validation:
    name: Build and Test Validation
    runs-on: ubuntu-latest
    needs: pre-flight-checks
    if: needs.pre-flight-checks.outputs.can_deploy == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Run Go tests
        run: |
          echo "üß™ Running Go tests..."
          cd backend
          go test -v -race -coverprofile=coverage.out ./...
          
          # Check coverage
          coverage=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "Test coverage: ${coverage}%"
          
          # Ensure minimum coverage
          min_coverage=60
          if (( $(echo "$coverage < $min_coverage" | bc -l) )); then
            echo "‚ùå Test coverage too low: ${coverage}% < ${min_coverage}%"
            exit 1
          fi
          
          echo "‚úÖ Go tests passed with ${coverage}% coverage"

      - name: Run linting
        run: |
          echo "üîç Running linters..."
          
          # Install golangci-lint
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2
          
          cd backend
          golangci-lint run --timeout=5m || {
            echo "‚ùå Linting issues found"
            exit 1
          }
          
          echo "‚úÖ Linting passed"

      - name: Build Docker image (test only)
        run: |
          echo "üê≥ Testing Docker build..."
          
          # Build but don't push - just validate it builds
          docker build -t test-build:${{ github.sha }} . || {
            echo "‚ùå Docker build failed"
            exit 1
          }
          
          # Run security scan on built image
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasecurity/trivy:latest image --severity CRITICAL,HIGH \
            --exit-code 1 test-build:${{ github.sha }} || {
            echo "‚ùå Critical vulnerabilities found in Docker image"
            exit 1
          }
          
          echo "‚úÖ Docker build successful and secure"

      - name: Run audio quality checks
        run: |
          echo "üéµ Running audio quality validation..."
          
          # Run all audio quality hooks
          for hook in hooks/check-*.sh; do
            if [ -f "$hook" ] && [[ "$hook" == *"audio"* || "$hook" == *"wav"* || "$hook" == *"quality"* ]]; then
              echo "Running $hook..."
              bash "$hook" || {
                echo "‚ùå Audio quality check failed: $hook"
                exit 1
              }
            fi
          done
          
          echo "‚úÖ Audio quality checks passed"

  # ============================================================================
  # PHASE 3: SECURITY VALIDATION (GitHub-hosted)
  # Deep security scanning before deployment
  # ============================================================================
  
  security-validation:
    name: Security Validation
    runs-on: ubuntu-latest
    needs: build-validation
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run dependency vulnerability scan
        run: |
          echo "üîí Scanning dependencies for vulnerabilities..."
          
          # Go vulnerability check
          cd backend
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./... || {
            echo "‚ö†Ô∏è Vulnerabilities found in Go dependencies"
            # Don't fail here, just warn
          }
          cd ..
          
          # Node.js vulnerability check
          if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
            cd frontend
            npm audit --audit-level=high || {
              echo "‚ö†Ô∏è Vulnerabilities found in Node.js dependencies"
              # Don't fail here, just warn
            }
            cd ..
          fi
          
          echo "‚úÖ Dependency scan complete"

      - name: SAST scan
        run: |
          echo "üîç Running static application security testing..."
          
          # Use semgrep for SAST
          pip install semgrep
          semgrep --config=auto --json -o sast-report.json . || true
          
          # Check for high-severity findings
          if [ -f sast-report.json ]; then
            high_findings=$(jq '[.results[] | select(.extra.severity == "ERROR")] | length' sast-report.json)
            if [ "$high_findings" -gt 0 ]; then
              echo "‚ùå High-severity security issues found: $high_findings"
              jq '.results[] | select(.extra.severity == "ERROR") | .extra.message' sast-report.json
              exit 1
            fi
          fi
          
          echo "‚úÖ SAST scan passed"

  # ============================================================================
  # PHASE 4: INTEGRATION TESTING (GitHub-hosted)
  # Test service integration without touching Pi
  # ============================================================================
  
  integration-testing:
    name: Integration Testing
    runs-on: ubuntu-latest
    needs: security-validation
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up test environment
        run: |
          echo "üß™ Setting up test environment..."
          
          # Create test docker-compose
          cat > docker-compose.test.yml << 'EOF'
          version: '3.8'
          services:
            minio:
              image: minio/minio:latest
              command: server /data
              environment:
                MINIO_ROOT_USER: testuser
                MINIO_ROOT_PASSWORD: testpass
              ports:
                - "9000:9000"
            
            app:
              build: .
              environment:
                MINIO_ENDPOINT: minio:9000
                MINIO_ACCESS_KEY: testuser
                MINIO_SECRET_KEY: testpass
                MINIO_BUCKET: test-sermons
              depends_on:
                - minio
              ports:
                - "8000:8000"
          EOF
          
          # Start test environment
          docker compose -f docker-compose.test.yml up -d
          
          # Wait for services
          sleep 30

      - name: Run integration tests
        run: |
          echo "üß™ Running integration tests..."
          
          # Test health endpoint
          curl -f http://localhost:8000/api/health || {
            echo "‚ùå Health check failed"
            docker compose -f docker-compose.test.yml logs
            exit 1
          }
          
          # Test MinIO connectivity
          curl -f http://localhost:9000/minio/health/live || {
            echo "‚ùå MinIO not healthy"
            exit 1
          }
          
          echo "‚úÖ Integration tests passed"

      - name: Cleanup test environment
        if: always()
        run: |
          docker compose -f docker-compose.test.yml down -v

  # ============================================================================
  # PHASE 5: FINAL SAFETY CHECK (GitHub-hosted)
  # Last validation before deployment
  # ============================================================================
  
  final-safety-check:
    name: Final Safety Check
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, build-validation, security-validation, integration-testing]
    outputs:
      deploy_approved: ${{ steps.final_decision.outputs.approved }}
    steps:
      - name: Compile validation results
        id: compile_results
        run: |
          echo "üìä Compiling all validation results..."
          echo "Pre-flight score: ${{ needs.pre-flight-checks.outputs.validation_score }}/100"
          echo "All validations passed successfully"

      - name: Final deployment decision
        id: final_decision
        run: |
          echo "üéØ Final deployment decision..."
          
          # Check if all previous jobs succeeded
          if [ "${{ needs.pre-flight-checks.result }}" != "success" ] || \
             [ "${{ needs.build-validation.result }}" != "success" ] || \
             [ "${{ needs.security-validation.result }}" != "success" ] || \
             [ "${{ needs.integration-testing.result }}" != "success" ]; then
            echo "‚ùå Not all validations passed"
            echo "approved=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ All validations passed - deployment approved"
          echo "approved=true" >> $GITHUB_OUTPUT

      - name: Send pre-deployment notification
        if: steps.final_decision.outputs.approved == 'true'
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "üöÄ Deployment Approved",
                  "description": "All validation checks passed. Starting deployment to Pi.",
                  "color": 3066993,
                  "fields": [
                    {"name": "Validation Score", "value": "${{ needs.pre-flight-checks.outputs.validation_score }}/100", "inline": true},
                    {"name": "Commit", "value": "`${{ github.sha }}`", "inline": true}
                  ]
                }]
              }'
          fi

  # ============================================================================
  # PHASE 6: ACTUAL DEPLOYMENT (Self-hosted on Pi)
  # Only runs if ALL validations pass
  # ============================================================================
  
  deploy-to-pi:
    name: Deploy to Production Pi
    runs-on: self-hosted
    needs: final-safety-check
    if: needs.final-safety-check.outputs.deploy_approved == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment backup
        run: |
          echo "üíæ Creating backup before deployment..."
          
          # Backup current container
          if docker ps -a --format "{{.Names}}" | grep -q "sermon-uploader"; then
            docker commit sermon-uploader sermon-uploader-backup:$(date +%Y%m%d-%H%M%S)
            echo "‚úÖ Backup created"
          fi

      - name: Build and deploy
        id: deploy
        run: |
          echo "üöÄ Deploying to Pi..."
          
          # Build new image
          docker build -t sermon-uploader:latest -t sermon-uploader:${{ github.sha }} .
          
          # Update container
          cd /home/gaius/actions-runner/_work/sermon-uploader/sermon-uploader
          docker compose -f docker-compose.single.yml down || true
          docker compose -f docker-compose.single.yml up -d
          
          # Wait for health check
          sleep 30
          
          # Verify deployment
          for i in {1..10}; do
            if curl -f http://localhost:8000/api/health; then
              echo "‚úÖ Deployment successful"
              exit 0
            fi
            echo "Waiting for service... (attempt $i/10)"
            sleep 10
          done
          
          echo "‚ùå Deployment verification failed"
          exit 1

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'failure'
        run: |
          echo "üîÑ Rolling back deployment..."
          
          # Restore from backup
          if docker images | grep -q "sermon-uploader-backup"; then
            docker tag sermon-uploader-backup:latest sermon-uploader:latest
            docker compose -f docker-compose.single.yml up -d
            echo "‚úÖ Rollback completed"
          fi

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            MESSAGE="‚úÖ Deployment successful"
            COLOR="3066993"
          else
            MESSAGE="‚ùå Deployment failed (rolled back)"
            COLOR="15158332"
          fi
          
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"Deployment Status\",
                  \"description\": \"$MESSAGE\",
                  \"color\": $COLOR
                }]
              }"
          fi

  # ============================================================================
  # PHASE 7: POST-DEPLOYMENT VERIFICATION (Self-hosted on Pi)
  # Verify the deployment is actually working
  # ============================================================================
  
  verify-deployment:
    name: Verify Deployment
    runs-on: self-hosted
    needs: deploy-to-pi
    if: success()
    steps:
      - name: Run health checks
        run: |
          echo "üè• Running post-deployment health checks..."
          
          # Check main service
          curl -f http://localhost:8000/api/health || exit 1
          
          # Check MinIO
          curl -f http://localhost:9000/minio/health/live || exit 1
          
          # Check resource usage
          docker stats --no-stream
          
          echo "‚úÖ All services healthy"

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests..."
          
          # Test upload endpoint exists
          curl -f http://localhost:8000/api/upload/presigned || echo "Upload endpoint check"
          
          # Test MinIO connectivity from app
          curl -f http://localhost:8000/api/health || exit 1
          
          echo "‚úÖ Smoke tests passed"

      - name: Final notification
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "‚úÖ Deployment Complete",
                  "description": "All validations and verifications passed. System is healthy.",
                  "color": 3066993,
                  "fields": [
                    {"name": "Version", "value": "`${{ github.sha }}`", "inline": true},
                    {"name": "Environment", "value": "Production", "inline": true}
                  ]
                }]
              }'
          fi