name: Production Deployment Pipeline

on:
  push:
    branches: [main, master]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'pi-processor/**'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - '.github/workflows/deploy-production.yml'
      - 'package.json'
      - 'go.mod'
      - 'start.sh'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean
      skip_rollback:
        description: 'Skip automatic rollback on failure'
        required: false
        default: false
        type: boolean

# Cancel in-progress deployments for the same branch
concurrency:
  group: deploy-production-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel production deployments

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GO_VERSION: '1.23'
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes
  HEALTH_CHECK_RETRIES: 10
  ROLLBACK_ENABLED: ${{ github.event.inputs.skip_rollback != 'true' }}

jobs:
  # Trigger pre-deployment validation
  trigger-validation:
    name: Trigger Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      validation_run_id: ${{ steps.trigger.outputs.run_id }}
    
    steps:
      - name: Trigger validation workflow
        id: trigger
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'pre-deployment-validation.yml',
              ref: context.ref,
              inputs: {
                triggered_by: 'deploy-production',
                commit_sha: context.sha
              }
            });
            
            // Wait a moment for the workflow to start
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Get the run ID
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'pre-deployment-validation.yml',
              head_sha: context.sha,
              per_page: 1
            });
            
            if (runs.data.workflow_runs.length > 0) {
              core.setOutput('run_id', runs.data.workflow_runs[0].id);
              console.log(`Triggered validation run: ${runs.data.workflow_runs[0].id}`);
            }

  # Wait for validation to complete
  await-validation:
    name: Await Pre-deployment Validation
    needs: trigger-validation
    runs-on: ubuntu-latest
    outputs:
      validation_status: ${{ steps.wait.outputs.status }}
    
    steps:
      - name: Wait for validation completion
        id: wait
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = ${{ needs.trigger-validation.outputs.validation_run_id }};
            if (!runId) {
              core.setFailed('No validation run ID provided');
              return;
            }
            
            let status = 'in_progress';
            let attempts = 0;
            const maxAttempts = 60; // 10 minutes max wait
            
            while (status === 'in_progress' && attempts < maxAttempts) {
              attempts++;
              
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });
              
              status = run.data.status;
              console.log(`Validation status: ${status} (attempt ${attempts}/${maxAttempts})`);
              
              if (status === 'in_progress') {
                await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
              }
            }
            
            if (status === 'completed') {
              const conclusion = (await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              })).data.conclusion;
              
              core.setOutput('status', conclusion);
              
              if (conclusion !== 'success') {
                core.setFailed(`Pre-deployment validation failed: ${conclusion}`);
              }
            } else {
              core.setFailed('Pre-deployment validation timed out or failed to complete');
            }

  # Discord notification for deployment start
  notify-deployment-start:
    name: Notify Deployment Start
    needs: await-validation
    runs-on: ubuntu-latest
    if: needs.await-validation.outputs.validation_status == 'success'
    
    steps:
      - name: Send Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK" ]; then
            curl -X POST "$DISCORD_WEBHOOK" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"🚀 Production Deployment Starting\",
                  \"description\": \"Beginning deployment of sermon uploader to production environment\",
                  \"color\": 16776960,
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\",
                  \"fields\": [
                    {\"name\": \"Repository\", \"value\": \"${{ github.repository }}\", \"inline\": true},
                    {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                    {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\", \"inline\": false},
                    {\"name\": \"Actor\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Environment\", \"value\": \"${{ github.event.inputs.environment || 'production' }}\", \"inline\": true}
                  ]
                }]
              }"
          fi

  # Build multi-platform images with comprehensive caching
  build-images:
    name: Build Production Images
    needs: await-validation
    runs-on: ubuntu-latest
    if: needs.await-validation.outputs.validation_status == 'success'
    
    strategy:
      matrix:
        component: [main, pi-processor]
        include:
          - component: main
            context: .
            dockerfile: ./Dockerfile
            image_suffix: ""
          - component: pi-processor  
            context: ./pi-processor
            dockerfile: ./pi-processor/Dockerfile
            image_suffix: "-pi-processor"
    
    outputs:
      main_image_tag: ${{ steps.meta-main.outputs.tags }}
      pi_image_tag: ${{ steps.meta-pi.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
          config-inline: |
            [registry."docker.io"]
              mirrors = ["https://mirror.gcr.io"]

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (main)
        if: matrix.component == 'main'
        id: meta-main
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=production-{{sha}}

      - name: Extract metadata (pi-processor)
        if: matrix.component == 'pi-processor'
        id: meta-pi
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}${{ matrix.image_suffix }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=production-{{sha}}

      - name: Build and push image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ matrix.component == 'main' && steps.meta-main.outputs.tags || steps.meta-pi.outputs.tags }}
          labels: ${{ matrix.component == 'main' && steps.meta-main.outputs.labels || steps.meta-pi.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.component }}
          cache-to: type=gha,mode=max,scope=${{ matrix.component }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}
            VERSION=${{ github.ref_name }}

      - name: Run security scan on built image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ matrix.component == 'main' && steps.meta-main.outputs.tags || steps.meta-pi.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.component }}.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results-${{ matrix.component }}.sarif'
        continue-on-error: true

  # Create deployment backup point
  create-backup:
    name: Create Pre-deployment Backup
    needs: build-images
    runs-on: self-hosted
    if: always() && needs.build-images.result == 'success'
    
    outputs:
      backup_created: ${{ steps.backup.outputs.created }}
      backup_path: ${{ steps.backup.outputs.path }}
      previous_version: ${{ steps.backup.outputs.previous_version }}
    
    steps:
      - name: Create deployment backup
        id: backup
        run: |
          echo "🔄 Creating pre-deployment backup..."
          
          BACKUP_DIR="/opt/sermon-uploader/backups"
          BACKUP_NAME="pre-deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          BACKUP_PATH="$BACKUP_DIR/$BACKUP_NAME"
          
          # Create backup directory
          mkdir -p "$BACKUP_DIR"
          
          # Navigate to project directory
          cd /opt/sermon-uploader
          
          # Capture current state
          echo "📊 Capturing current deployment state..."
          
          # Get current running container version
          PREVIOUS_VERSION=$(docker compose -f docker-compose.single.yml images sermon-uploader --format "table {{.Tag}}" | tail -n +2 | head -n 1 || echo "unknown")
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          
          # Create backup manifest
          cat > "$BACKUP_PATH.manifest" << EOF
          BACKUP_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          COMMIT_SHA=${{ github.sha }}
          PREVIOUS_VERSION=$PREVIOUS_VERSION
          BACKUP_TYPE=pre-deployment
          PROJECT_PATH=/opt/sermon-uploader
          EOF
          
          # Backup environment and compose files
          mkdir -p "$BACKUP_PATH"
          cp -r .env docker-compose*.yml "$BACKUP_PATH/" 2>/dev/null || true
          
          # Backup any custom configuration
          if [ -d "config" ]; then
            cp -r config "$BACKUP_PATH/"
          fi
          
          # Export current docker-compose configuration
          docker compose -f docker-compose.single.yml config > "$BACKUP_PATH/docker-compose.resolved.yml" 2>/dev/null || true
          
          # Create rollback script
          cat > "$BACKUP_PATH/rollback.sh" << 'ROLLBACK_EOF'
          #!/bin/bash
          set -e
          
          echo "🔄 Rolling back to previous version..."
          
          MANIFEST_FILE="$(dirname "$0")/$(basename "$0" .sh).manifest"
          if [ -f "$MANIFEST_FILE" ]; then
            source "$MANIFEST_FILE"
            echo "Rolling back to commit: $COMMIT_SHA"
            echo "Previous version: $PREVIOUS_VERSION"
          fi
          
          # Stop current services
          docker compose -f docker-compose.single.yml down || true
          
          # Restore configuration files
          if [ -f "$(dirname "$0")/.env" ]; then
            cp "$(dirname "$0")/.env" /opt/sermon-uploader/
          fi
          
          # Pull previous image if known
          if [ "$PREVIOUS_VERSION" != "unknown" ]; then
            echo "📦 Pulling previous image version..."
            sed -i "s|ghcr.io/white-plains-gospel-chapel/sermon-uploader:.*|ghcr.io/white-plains-gospel-chapel/sermon-uploader:$PREVIOUS_VERSION|" docker-compose.single.yml
            docker compose -f docker-compose.single.yml pull || echo "⚠️ Failed to pull previous version"
          fi
          
          # Restart services
          docker compose -f docker-compose.single.yml up -d
          
          echo "✅ Rollback completed"
          ROLLBACK_EOF
          
          chmod +x "$BACKUP_PATH/rollback.sh"
          
          # Keep only last 10 backups
          ls -1t "$BACKUP_DIR" | tail -n +11 | xargs -r -I {} rm -rf "$BACKUP_DIR/{}"
          
          echo "created=true" >> $GITHUB_OUTPUT
          echo "path=$BACKUP_PATH" >> $GITHUB_OUTPUT
          
          echo "✅ Backup created at: $BACKUP_PATH"

  # Deploy to Raspberry Pi with comprehensive monitoring
  deploy-to-pi:
    name: Deploy to Raspberry Pi
    needs: [build-images, create-backup]
    runs-on: self-hosted
    if: always() && needs.build-images.result == 'success' && needs.create-backup.result == 'success'
    timeout-minutes: 15
    
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      service_health: ${{ steps.health-check.outputs.status }}
      deployment_time: ${{ steps.deploy.outputs.deployment_time }}
    
    steps:
      - name: Pre-deployment system check
        id: system-check
        run: |
          echo "🔍 Performing pre-deployment system check..."
          
          # Check system resources
          echo "💾 System Resources:"
          df -h /
          free -h
          echo ""
          
          # Check Docker system
          echo "🐳 Docker System:"
          docker system df
          docker system info | grep -E "Server Version|Storage Driver|Logging Driver"
          echo ""
          
          # Check current services
          echo "📊 Current Services:"
          docker compose -f /opt/sermon-uploader/docker-compose.single.yml ps || echo "No services running"
          echo ""
          
          # Check network connectivity
          echo "🌐 Network Check:"
          curl -s --max-time 5 https://ghcr.io/v2/ > /dev/null && echo "✅ Registry accessible" || echo "❌ Registry not accessible"
          
          # Check available space for images
          AVAILABLE_SPACE=$(df /var/lib/docker --output=avail | tail -n 1)
          if [ "$AVAILABLE_SPACE" -lt 2097152 ]; then  # 2GB in KB
            echo "⚠️ Low disk space available for Docker images"
            docker system prune -af || true
          fi

      - name: Deploy application
        id: deploy
        run: |
          echo "🚀 Starting deployment to Raspberry Pi..."
          
          DEPLOYMENT_START=$(date +%s)
          
          # Navigate to project directory
          cd /opt/sermon-uploader
          
          # Pull latest code
          echo "📥 Pulling latest code..."
          git fetch origin
          git reset --hard origin/main
          
          # Create/update .env file with secrets
          echo "⚙️ Updating environment configuration..."
          cat > .env << 'EOL'
          # MinIO Configuration
          MINIO_ENDPOINT=${{ secrets.MINIO_ENDPOINT || 'http://localhost:9000' }}
          MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
          MINIO_SECURE=${{ secrets.MINIO_SECURE || 'false' }}
          MINIO_BUCKET=${{ secrets.MINIO_BUCKET || 'sermons' }}
          
          # Discord Configuration  
          DISCORD_WEBHOOK_URL=${{ secrets.DISCORD_WEBHOOK_URL }}
          
          # Application Configuration
          WAV_SUFFIX=${{ secrets.WAV_SUFFIX || '_raw' }}
          AAC_SUFFIX=${{ secrets.AAC_SUFFIX || '_streamable' }}
          BATCH_THRESHOLD=${{ secrets.BATCH_THRESHOLD || '2' }}
          PORT=${{ secrets.PORT || '8000' }}
          
          # Deployment Metadata
          DEPLOYMENT_ID=${{ github.sha }}
          IMAGE_REVISION=${{ github.sha }}
          DEPLOYMENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          BUILD_VERSION=${{ github.run_number }}
          DEPLOY_ACTOR=${{ github.actor }}
          EOL
          
          chmod 600 .env
          
          # Update docker-compose with new image
          echo "📦 Updating container configuration..."
          sed -i "s|ghcr.io/white-plains-gospel-chapel/sermon-uploader:.*|ghcr.io/white-plains-gospel-chapel/sermon-uploader:production-${{ github.sha }}|" docker-compose.single.yml
          
          # Pull new images
          echo "📥 Pulling new container images..."
          docker compose -f docker-compose.single.yml pull
          
          # Perform rolling update
          echo "🔄 Performing rolling update..."
          docker compose -f docker-compose.single.yml up -d --force-recreate
          
          DEPLOYMENT_END=$(date +%s)
          DEPLOYMENT_TIME=$((DEPLOYMENT_END - DEPLOYMENT_START))
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "deployment_time=${DEPLOYMENT_TIME}s" >> $GITHUB_OUTPUT
          
          echo "✅ Deployment completed in ${DEPLOYMENT_TIME} seconds"

      - name: Comprehensive health check
        id: health-check
        run: |
          echo "🏥 Performing comprehensive health check..."
          
          cd /opt/sermon-uploader
          
          # Wait for containers to start
          echo "⏳ Waiting for containers to start..."
          sleep 30
          
          # Check container status
          echo "📊 Container Status:"
          docker compose -f docker-compose.single.yml ps
          
          if ! docker compose -f docker-compose.single.yml ps sermon-uploader | grep -q "Up"; then
            echo "❌ Container failed to start"
            echo "📝 Container logs:"
            docker compose -f docker-compose.single.yml logs sermon-uploader --tail=50
            echo "status=container_failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Health check with retries
          echo "🔍 Performing health checks..."
          
          HEALTH_CHECKS=(
            "http://localhost:8000/api/health|Main API Health"
            "http://localhost:9000/minio/health/live|MinIO Health"
            "http://localhost:8000/api/status|Application Status"
          )
          
          ALL_HEALTHY=true
          
          for check in "${HEALTH_CHECKS[@]}"; do
            URL=$(echo "$check" | cut -d'|' -f1)
            NAME=$(echo "$check" | cut -d'|' -f2)
            
            echo "🔍 Checking $NAME..."
            
            HEALTHY=false
            for i in {1..5}; do
              if curl -f --max-time 10 "$URL" >/dev/null 2>&1; then
                echo "✅ $NAME: Healthy (attempt $i)"
                HEALTHY=true
                break
              else
                echo "⏳ $NAME: Not ready, retrying in 10s... (attempt $i/5)"
                sleep 10
              fi
            done
            
            if [ "$HEALTHY" = false ]; then
              echo "❌ $NAME: Failed health check"
              ALL_HEALTHY=false
            fi
          done
          
          # Performance test
          echo "⚡ Performance test..."
          RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null --max-time 30 "http://localhost:8000/api/health" || echo "timeout")
          if [ "$RESPONSE_TIME" != "timeout" ] && (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
            echo "✅ Response time: ${RESPONSE_TIME}s (good)"
          else
            echo "⚠️ Response time: ${RESPONSE_TIME}s (slow or timeout)"
          fi
          
          if [ "$ALL_HEALTHY" = true ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "✅ All health checks passed"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "❌ Some health checks failed"
            
            # Show detailed diagnostics
            echo "📝 Detailed diagnostics:"
            docker compose -f docker-compose.single.yml logs sermon-uploader --tail=100
            exit 1
          fi

      - name: Performance monitoring setup
        if: steps.health-check.outputs.status == 'healthy'
        run: |
          echo "📊 Setting up performance monitoring..."
          
          # Basic performance metrics collection
          cat > /tmp/perf-monitor.sh << 'PERF_EOF'
          #!/bin/bash
          while true; do
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            CPU_USAGE=$(docker stats --no-stream --format "{{.CPUPerc}}" sermon-uploader-sermon-uploader-1 | sed 's/%//')
            MEM_USAGE=$(docker stats --no-stream --format "{{.MemPerc}}" sermon-uploader-sermon-uploader-1 | sed 's/%//')
            
            echo "[$TIMESTAMP] CPU: ${CPU_USAGE}%, Memory: ${MEM_USAGE}%"
            
            sleep 60
          done
          PERF_EOF
          
          chmod +x /tmp/perf-monitor.sh
          nohup /tmp/perf-monitor.sh > /tmp/perf.log 2>&1 &
          echo $! > /tmp/perf-monitor.pid
          
          echo "✅ Performance monitoring started"

  # Automatic rollback on failure
  auto-rollback:
    name: Automatic Rollback
    needs: [create-backup, deploy-to-pi]
    runs-on: self-hosted
    if: |
      always() && 
      env.ROLLBACK_ENABLED == 'true' &&
      needs.create-backup.result == 'success' &&
      needs.deploy-to-pi.result == 'failure' &&
      needs.create-backup.outputs.backup_created == 'true'
    
    steps:
      - name: Execute rollback
        run: |
          echo "🔄 Executing automatic rollback..."
          
          BACKUP_PATH="${{ needs.create-backup.outputs.backup_path }}"
          
          if [ -f "$BACKUP_PATH/rollback.sh" ]; then
            echo "📜 Executing rollback script..."
            cd /opt/sermon-uploader
            bash "$BACKUP_PATH/rollback.sh"
            
            # Verify rollback
            sleep 30
            if curl -f http://localhost:8000/api/health >/dev/null 2>&1; then
              echo "✅ Rollback successful - service is healthy"
            else
              echo "❌ Rollback completed but service is not responding"
            fi
          else
            echo "❌ Rollback script not found at $BACKUP_PATH/rollback.sh"
          fi

      - name: Notify rollback
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK" ]; then
            curl -X POST "$DISCORD_WEBHOOK" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"⏪ Automatic Rollback Executed\",
                  \"description\": \"Deployment failed, automatically rolled back to previous version\",
                  \"color\": 16753920,
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\",
                  \"fields\": [
                    {\"name\": \"Repository\", \"value\": \"${{ github.repository }}\", \"inline\": true},
                    {\"name\": \"Failed Commit\", \"value\": \"${{ github.sha }}\", \"inline\": true},
                    {\"name\": \"Previous Version\", \"value\": \"${{ needs.create-backup.outputs.previous_version }}\", \"inline\": true}
                  ]
                }]
              }"
          fi

  # Trigger post-deployment verification
  trigger-verification:
    name: Trigger Post-deployment Verification
    needs: deploy-to-pi
    runs-on: ubuntu-latest
    if: needs.deploy-to-pi.outputs.deployment_status == 'success' && needs.deploy-to-pi.outputs.service_health == 'healthy'
    
    steps:
      - name: Trigger verification workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'post-deployment-verification.yml',
              ref: context.ref,
              inputs: {
                deployment_commit: context.sha,
                environment: '${{ github.event.inputs.environment || 'production' }}',
                deployment_time: '${{ needs.deploy-to-pi.outputs.deployment_time }}'
              }
            });

  # Final deployment notification
  notify-completion:
    name: Notify Deployment Completion
    needs: [deploy-to-pi, auto-rollback]
    runs-on: ubuntu-latest
    if: always() && (needs.deploy-to-pi.result == 'success' || needs.auto-rollback.result == 'success')
    
    steps:
      - name: Send completion notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK" ]; then
            if [ "${{ needs.deploy-to-pi.result }}" = "success" ]; then
              TITLE="✅ Production Deployment Successful"
              DESCRIPTION="Sermon uploader successfully deployed to production"
              COLOR=65280  # Green
              STATUS="✅ Success"
            else
              TITLE="⚠️ Deployment Failed - Rollback Complete"
              DESCRIPTION="Deployment failed but system was automatically rolled back"
              COLOR=16753920  # Orange
              STATUS="⚠️ Failed + Rolled Back"
            fi
            
            curl -X POST "$DISCORD_WEBHOOK" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"$TITLE\",
                  \"description\": \"$DESCRIPTION\",
                  \"color\": $COLOR,
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.000Z)\",
                  \"fields\": [
                    {\"name\": \"Repository\", \"value\": \"${{ github.repository }}\", \"inline\": true},
                    {\"name\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"inline\": true},
                    {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\", \"inline\": false},
                    {\"name\": \"Status\", \"value\": \"$STATUS\", \"inline\": true},
                    {\"name\": \"Actor\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Duration\", \"value\": \"${{ needs.deploy-to-pi.outputs.deployment_time || 'N/A' }}\", \"inline\": true}
                  ]
                }]
              }"
          fi

  # Cleanup job
  cleanup:
    name: Cleanup
    needs: [deploy-to-pi, auto-rollback, notify-completion]
    runs-on: self-hosted
    if: always()
    
    steps:
      - name: Cleanup deployment artifacts
        run: |
          echo "🧹 Cleaning up deployment artifacts..."
          
          # Clean up old Docker images
          docker image prune -af --filter="until=24h" || true
          
          # Clean up old containers
          docker container prune -f --filter="until=24h" || true
          
          # Stop performance monitoring if running
          if [ -f /tmp/perf-monitor.pid ]; then
            PID=$(cat /tmp/perf-monitor.pid)
            kill $PID 2>/dev/null || true
            rm -f /tmp/perf-monitor.pid
          fi
          
          # Archive performance logs
          if [ -f /tmp/perf.log ]; then
            mv /tmp/perf.log "/opt/sermon-uploader/logs/perf-$(date +%Y%m%d-%H%M%S).log" 2>/dev/null || rm -f /tmp/perf.log
          fi
          
          echo "✅ Cleanup completed"