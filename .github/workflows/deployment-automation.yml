name: Deployment Automation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [master, main]
  push:
    branches: [master, main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
          - pi-staging
          - pi-production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Job 1: Environment Detection and Setup
  environment-setup:
    name: Environment Setup
    runs-on: ubuntu-latest
    outputs:
      deploy-to-staging: ${{ steps.determine.outputs.deploy-to-staging }}
      deploy-to-production: ${{ steps.determine.outputs.deploy-to-production }}
      environment-type: ${{ steps.determine.outputs.environment-type }}
      deployment-target: ${{ steps.determine.outputs.deployment-target }}
    
    steps:
      - name: Determine deployment strategy
        id: determine
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual deployment
            ENV="${{ github.event.inputs.environment }}"
            echo "Manual deployment to: $ENV"
            echo "deployment-target=$ENV" >> $GITHUB_OUTPUT
            
            if [[ "$ENV" == *"staging"* ]]; then
              echo "deploy-to-staging=true" >> $GITHUB_OUTPUT
              echo "deploy-to-production=false" >> $GITHUB_OUTPUT
              echo "environment-type=staging" >> $GITHUB_OUTPUT
            else
              echo "deploy-to-staging=false" >> $GITHUB_OUTPUT
              echo "deploy-to-production=true" >> $GITHUB_OUTPUT
              echo "environment-type=production" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # PR preview deployments
            echo "PR deployment - creating preview environment"
            echo "deploy-to-staging=true" >> $GITHUB_OUTPUT
            echo "deploy-to-production=false" >> $GITHUB_OUTPUT
            echo "environment-type=preview" >> $GITHUB_OUTPUT
            echo "deployment-target=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]] || [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch push - deploy to production
            echo "Main branch push - deploying to production"
            echo "deploy-to-staging=false" >> $GITHUB_OUTPUT
            echo "deploy-to-production=true" >> $GITHUB_OUTPUT
            echo "environment-type=production" >> $GITHUB_OUTPUT
            echo "deployment-target=production" >> $GITHUB_OUTPUT
          else
            # Other branches - no deployment
            echo "No deployment triggered for this event"
            echo "deploy-to-staging=false" >> $GITHUB_OUTPUT
            echo "deploy-to-production=false" >> $GITHUB_OUTPUT
            echo "environment-type=none" >> $GITHUB_OUTPUT
            echo "deployment-target=none" >> $GITHUB_OUTPUT
          fi

  # Job 2: Build and Test for Deployment
  build-for-deployment:
    name: Build for Deployment
    runs-on: ubuntu-latest
    needs: environment-setup
    if: needs.environment-setup.outputs.deployment-target != 'none'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up build cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build production images
        run: |
          # Tag images with commit SHA and environment
          IMAGE_TAG="${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}"
          
          echo "Building images with tag: $IMAGE_TAG"
          
          # Build backend
          docker build -f backend/Dockerfile -t sermon-uploader-backend:$IMAGE_TAG backend/
          
          # Build frontend
          docker build -f frontend/Dockerfile -t sermon-uploader-frontend:$IMAGE_TAG frontend/
          
          # Save images as artifacts
          docker save sermon-uploader-backend:$IMAGE_TAG > backend-image.tar
          docker save sermon-uploader-frontend:$IMAGE_TAG > frontend-image.tar

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: docker-images-${{ needs.environment-setup.outputs.deployment-target }}
          path: |
            backend-image.tar
            frontend-image.tar
          retention-days: 7

      - name: Test images
        run: |
          IMAGE_TAG="${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}"
          
          # Test backend image
          docker run --rm -d --name test-backend -p 8080:8080 \
            -e MINIO_ENDPOINT=mock.test \
            sermon-uploader-backend:$IMAGE_TAG
          
          sleep 5
          
          # Test health endpoint
          if curl -f http://localhost:8080/health; then
            echo "‚úÖ Backend health check passed"
          else
            echo "‚ùå Backend health check failed"
            exit 1
          fi
          
          docker stop test-backend

  # Job 3: Staging Deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [environment-setup, build-for-deployment]
    if: needs.environment-setup.outputs.deploy-to-staging == 'true'
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.staging-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: docker-images-${{ needs.environment-setup.outputs.deployment-target }}

      - name: Load Docker images
        run: |
          docker load < backend-image.tar
          docker load < frontend-image.tar

      - name: Deploy to staging environment
        id: deploy
        run: |
          IMAGE_TAG="${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}"
          DEPLOYMENT_ID="staging-$(date +%s)"
          
          # Create staging docker-compose override
          cat > docker-compose.staging.yml << EOF
          version: '3.8'
          services:
            backend:
              image: sermon-uploader-backend:$IMAGE_TAG
              environment:
                - ENVIRONMENT=staging
                - MINIO_ENDPOINT=\${MINIO_ENDPOINT:-localhost:9000}
                - MINIO_ACCESS_KEY=\${MINIO_ACCESS_KEY:-staging_access}
                - MINIO_SECRET_KEY=\${MINIO_SECRET_KEY:-staging_secret}
                - DISCORD_WEBHOOK_URL=\${STAGING_DISCORD_WEBHOOK_URL}
              ports:
                - "8080:8080"
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
            
            frontend:
              image: sermon-uploader-frontend:$IMAGE_TAG
              environment:
                - NODE_ENV=staging
                - NEXT_PUBLIC_API_URL=http://localhost:8080/api
              ports:
                - "3000:3000"
              depends_on:
                - backend
          
            minio-staging:
              image: minio/minio
              command: server /data --console-address ":9001"
              environment:
                - MINIO_ACCESS_KEY=staging_access
                - MINIO_SECRET_KEY=staging_secret
              ports:
                - "9000:9000"
                - "9001:9001"
              volumes:
                - staging_data:/data
          
          volumes:
            staging_data:
          EOF
          
          # Deploy to staging
          docker-compose -f docker-compose.staging.yml up -d
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Health checks
          if curl -f http://localhost:8080/health; then
            echo "‚úÖ Backend staging deployment successful"
          else
            echo "‚ùå Backend staging deployment failed"
            docker-compose -f docker-compose.staging.yml logs backend
            exit 1
          fi
          
          echo "staging-url=http://localhost:3000" >> $GITHUB_OUTPUT
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Run deployment tests
        run: |
          # API tests
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/api/upload/presigned || true
          
          # Frontend tests (basic connectivity)
          curl -f http://localhost:3000 || exit 1
          
          echo "‚úÖ Staging deployment tests passed"

      - name: Comment on PR with staging info
        if: github.event_name == 'pull_request'
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          gh pr comment $PR_NUMBER --body "üöÄ **STAGING DEPLOYMENT**
          
          **Environment**: Staging Preview
          **Deployment ID**: ${{ steps.deploy.outputs.deployment-id }}
          **URLs**:
          - üåê Frontend: http://localhost:3000
          - üîß Backend API: http://localhost:8080
          - üìä MinIO Console: http://localhost:9001
          
          **Status**: ‚úÖ Deployed successfully
          **Docker Images**:
          - Backend: \`sermon-uploader-backend:${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}\`
          - Frontend: \`sermon-uploader-frontend:${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}\`
          
          **Testing**: All health checks passed
          
          This preview environment will be available until the PR is closed."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 4: Production Deployment (with approval)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [environment-setup, build-for-deployment]
    if: needs.environment-setup.outputs.deploy-to-production == 'true'
    environment:
      name: production
      url: ${{ steps.deploy.outputs.production-url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: docker-images-${{ needs.environment-setup.outputs.deployment-target }}

      - name: Load Docker images
        run: |
          docker load < backend-image.tar
          docker load < frontend-image.tar

      - name: Pre-deployment backup
        run: |
          echo "üîÑ Creating pre-deployment backup..."
          
          # Backup current deployment state
          BACKUP_DIR="backup-$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$BACKUP_DIR"
          
          # Save current docker-compose state
          if docker-compose ps > /dev/null 2>&1; then
            docker-compose config > "$BACKUP_DIR/docker-compose-backup.yml"
            docker-compose ps --format json > "$BACKUP_DIR/container-state.json"
          fi
          
          echo "BACKUP_DIR=$BACKUP_DIR" >> $GITHUB_ENV

      - name: Deploy to production
        id: deploy
        run: |
          IMAGE_TAG="${{ github.sha }}-${{ needs.environment-setup.outputs.deployment-target }}"
          
          # Create production docker-compose configuration
          cat > docker-compose.production.yml << EOF
          version: '3.8'
          services:
            backend:
              image: sermon-uploader-backend:$IMAGE_TAG
              environment:
                - ENVIRONMENT=production
                - MINIO_ENDPOINT=\${MINIO_ENDPOINT:-192.168.1.127:9000}
                - MINIO_ACCESS_KEY=\${MINIO_ACCESS_KEY}
                - MINIO_SECRET_KEY=\${MINIO_SECRET_KEY}
                - DISCORD_WEBHOOK_URL=\${DISCORD_WEBHOOK_URL}
              ports:
                - "8080:8080"
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
              logging:
                driver: "json-file"
                options:
                  max-size: "10m"
                  max-file: "3"
            
            frontend:
              image: sermon-uploader-frontend:$IMAGE_TAG
              environment:
                - NODE_ENV=production
                - NEXT_PUBLIC_API_URL=\${NEXT_PUBLIC_API_URL:-http://localhost:8080/api}
              ports:
                - "3000:3000"
              restart: unless-stopped
              depends_on:
                - backend
              logging:
                driver: "json-file"
                options:
                  max-size: "10m"
                  max-file: "3"
          EOF
          
          # Rolling update deployment
          echo "üöÄ Starting production deployment..."
          
          # Deploy with zero-downtime strategy
          docker-compose -f docker-compose.production.yml pull 2>/dev/null || true
          docker-compose -f docker-compose.production.yml up -d --remove-orphans
          
          # Wait for services
          echo "‚è≥ Waiting for services to be ready..."
          sleep 45
          
          # Health checks with retry
          for i in {1..5}; do
            if curl -f http://localhost:8080/health; then
              echo "‚úÖ Production backend is healthy"
              break
            else
              echo "‚ö†Ô∏è Health check attempt $i/5 failed, retrying..."
              sleep 10
              if [ $i -eq 5 ]; then
                echo "‚ùå Production deployment failed health checks"
                exit 1
              fi
            fi
          done
          
          echo "production-url=http://localhost:3000" >> $GITHUB_OUTPUT

      - name: Post-deployment validation
        run: |
          # Comprehensive production tests
          echo "üîç Running post-deployment validation..."
          
          # API endpoints
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/api/upload/presigned || true
          
          # Frontend
          curl -f http://localhost:3000 || exit 1
          
          # Check container health
          if ! docker-compose -f docker-compose.production.yml ps | grep -q "Up"; then
            echo "‚ùå Some containers are not running properly"
            docker-compose -f docker-compose.production.yml ps
            exit 1
          fi
          
          echo "‚úÖ Production deployment validation passed"

      - name: Cleanup old images
        run: |
          echo "üßπ Cleaning up old Docker images..."
          
          # Keep last 3 images, remove older ones
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
          grep "sermon-uploader" | \
          sort -k2 -r | \
          tail -n +4 | \
          awk '{print $1}' | \
          xargs -r docker rmi || true

      - name: Send deployment notification
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "üöÄ Production Deployment Successful",
                  "description": "Sermon Uploader has been deployed to production",
                  "color": 3066993,
                  "fields": [
                    {"name": "Version", "value": "'${{ github.sha }}' (first 8 chars)", "inline": true},
                    {"name": "Environment", "value": "Production", "inline": true},
                    {"name": "Status", "value": "‚úÖ Active", "inline": true}
                  ],
                  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%S.000Z)'"
                }]
              }' \
              "${{ secrets.DISCORD_WEBHOOK_URL }}"
          fi

  # Job 5: Pi-specific Deployment
  deploy-pi:
    name: Deploy to Raspberry Pi
    runs-on: ubuntu-latest
    needs: [environment-setup, build-for-deployment]
    if: contains(needs.environment-setup.outputs.deployment-target, 'pi')
    environment:
      name: pi-${{ contains(needs.environment-setup.outputs.deployment-target, 'production') && 'production' || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH for Pi deployment
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PI_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PI_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Raspberry Pi
        run: |
          PI_HOST="${{ secrets.PI_HOST }}"
          PI_USER="${{ secrets.PI_USER || 'pi' }}"
          
          echo "üöÄ Deploying to Raspberry Pi: $PI_USER@$PI_HOST"
          
          # Copy deployment files
          scp docker-compose.pi.yml $PI_USER@$PI_HOST:~/sermon-uploader/
          scp -r .env.pi $PI_USER@$PI_HOST:~/sermon-uploader/.env
          
          # Execute deployment on Pi
          ssh $PI_USER@$PI_HOST << 'EOF'
            cd ~/sermon-uploader
            
            # Pull latest images (if using registry)
            # docker-compose pull
            
            # Deploy with Pi-specific configuration
            docker-compose -f docker-compose.pi.yml up -d --remove-orphans
            
            # Wait for services
            sleep 30
            
            # Health check
            curl -f http://localhost:8080/health || exit 1
            
            echo "‚úÖ Pi deployment successful"
          EOF

  # Job 6: Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-production.result == 'failure' || needs.deploy-pi.result == 'failure')
    needs: [deploy-production, deploy-pi]
    
    steps:
      - name: Rollback to previous version
        run: |
          echo "üîÑ Rolling back deployment..."
          
          # Restore from backup if available
          if [ -n "$BACKUP_DIR" ] && [ -d "$BACKUP_DIR" ]; then
            echo "Restoring from backup: $BACKUP_DIR"
            docker-compose -f "$BACKUP_DIR/docker-compose-backup.yml" up -d
          else
            echo "No backup available, stopping failed containers"
            docker-compose down
          fi
          
          # Send rollback notification
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "‚ö†Ô∏è Deployment Rolled Back",
                  "description": "Production deployment failed and has been rolled back",
                  "color": 15158332,
                  "fields": [
                    {"name": "Status", "value": "‚ùå Failed, Rolled Back", "inline": true}
                  ]
                }]
              }' \
              "${{ secrets.DISCORD_WEBHOOK_URL }}"
          fi

  # Job 7: Cleanup Preview Environments
  cleanup-preview:
    name: Cleanup Preview Environment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    
    steps:
      - name: Cleanup PR preview environment
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          DEPLOYMENT_TARGET="pr-$PR_NUMBER"
          
          echo "üßπ Cleaning up preview environment for PR #$PR_NUMBER"
          
          # Stop and remove containers for this PR
          docker-compose -f docker-compose.staging.yml -p "pr-$PR_NUMBER" down -v
          
          # Remove tagged images
          docker images --format "{{.Repository}}:{{.Tag}}" | grep "$DEPLOYMENT_TARGET" | xargs -r docker rmi
          
          # Comment on PR
          gh pr comment $PR_NUMBER --body "üßπ **Preview environment cleaned up**
          
          The staging preview environment for this PR has been automatically removed."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}