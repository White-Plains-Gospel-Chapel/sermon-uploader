name: Audio Quality Monitoring & Alerting

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of monitoring check'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - audio-only
          - performance
          - integrity

permissions:
  contents: read
  issues: write

env:
  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
  MONITORING_INTERVAL: '6h'

jobs:
  audio-quality-monitoring:
    name: ðŸŽµ Audio Quality Health Check
    runs-on: ubuntu-latest
    outputs:
      audio-health-status: ${{ steps.audio-check.outputs.status }}
      performance-status: ${{ steps.performance-check.outputs.status }}
      integrity-status: ${{ steps.integrity-check.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up monitoring environment
        run: |
          echo "ðŸ” Setting up audio quality monitoring..."
          
          # Create monitoring directory
          mkdir -p monitoring_reports
          
          # Set monitoring timestamp
          echo "MONITORING_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          echo "MONITORING_ID=$(date +%s)" >> $GITHUB_ENV

      - name: Audio quality configuration check
        id: audio-check
        run: |
          echo "ðŸŽµ Checking audio quality configuration..."
          
          ISSUES=()
          STATUS="healthy"
          
          # Check 1: Verify audio/wav content type is still present
          if ! grep -r "audio/wav" backend/services/ backend/handlers/ > /dev/null; then
            ISSUES+=("âŒ CRITICAL: audio/wav content type missing from codebase")
            STATUS="critical"
          fi
          
          # Check 2: Ensure no compression has been introduced
          if grep -r -i "compress.*audio\|gzip.*wav\|deflate.*audio" backend/ --include="*.go" | grep -v test; then
            ISSUES+=("âŒ CRITICAL: Audio compression detected in backend")
            STATUS="critical"
          fi
          
          # Check 3: Check MinIO operations preserve quality
          if ! grep -A5 -B5 "PutObjectOptions" backend/services/minio* | grep -E "(audio/wav|NO compression)" > /dev/null; then
            ISSUES+=("âš ï¸  WARNING: MinIO operations may lack quality preservation")
            if [ "$STATUS" != "critical" ]; then
              STATUS="warning"
            fi
          fi
          
          # Check 4: Verify upload integrity checks exist
          if ! grep -r "sha256\|hash.*sum\|integrity" backend/services/ backend/handlers/ > /dev/null; then
            ISSUES+=("âš ï¸  WARNING: File integrity verification may be missing")
            if [ "$STATUS" != "critical" ]; then
              STATUS="warning"
            fi
          fi
          
          # Check 5: Frontend file modification check
          if grep -r -i "transform.*file\|convert.*audio\|compress.*upload" frontend/src/ --include="*.ts" --include="*.tsx" | grep -v test | grep -v node_modules; then
            ISSUES+=("âŒ CRITICAL: File modification detected in frontend")
            STATUS="critical"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          
          # Generate audio quality report
          cat > monitoring_reports/audio_quality_report.md << EOF
          # ðŸŽµ Audio Quality Health Report
          
          **Status:** $STATUS
          **Timestamp:** ${{ env.MONITORING_TIMESTAMP }}
          **Monitoring ID:** ${{ env.MONITORING_ID }}
          
          ## Configuration Checks
          
          - [$([ "$STATUS" != "critical" ] && echo "x" || echo " ")] Audio/WAV content type preservation
          - [$([ "$STATUS" != "critical" ] && echo "x" || echo " ")] No compression in audio paths
          - [$([ "$STATUS" != "critical" ] && echo "x" || echo " ")] MinIO quality preservation
          - [$([ "$STATUS" != "critical" ] && echo "x" || echo " ")] File integrity verification
          - [$([ "$STATUS" != "critical" ] && echo "x" || echo " ")] Frontend file integrity
          
          $(if [ ${#ISSUES[@]} -gt 0 ]; then
            echo "## Issues Detected"
            printf '%s\n' "${ISSUES[@]}"
          else
            echo "## Status"
            echo "âœ… All audio quality configuration checks passed"
          fi)
          EOF
          
          if [ ${#ISSUES[@]} -gt 0 ]; then
            echo "ðŸš¨ Audio quality issues detected:"
            printf '%s\n' "${ISSUES[@]}"
          else
            echo "âœ… Audio quality configuration healthy"
          fi

      - name: Performance monitoring check
        id: performance-check
        run: |
          echo "ðŸš€ Checking performance metrics..."
          
          PERF_ISSUES=()
          PERF_STATUS="healthy"
          
          # Check 1: Verify no performance-degrading changes
          if git log --oneline -10 | grep -i "performance\|slow\|timeout"; then
            echo "âš ï¸  Recent performance-related commits detected"
          fi
          
          # Check 2: Bundle size analysis (simulated)
          echo "Analyzing bundle sizes..."
          BACKEND_SIZE=$(du -sh backend/ | cut -f1)
          FRONTEND_SIZE=$(du -sh frontend/ | cut -f1)
          
          echo "Backend size: $BACKEND_SIZE"
          echo "Frontend size: $FRONTEND_SIZE"
          
          # Check 3: Docker image size monitoring
          if [ -f "backend/Dockerfile" ]; then
            echo "Checking Dockerfile efficiency..."
            DOCKERFILE_LINES=$(wc -l < backend/Dockerfile)
            if [ $DOCKERFILE_LINES -gt 50 ]; then
              PERF_ISSUES+=("âš ï¸  Backend Dockerfile may be inefficient ($DOCKERFILE_LINES lines)")
              PERF_STATUS="warning"
            fi
          fi
          
          echo "status=$PERF_STATUS" >> $GITHUB_OUTPUT
          
          # Generate performance report
          cat > monitoring_reports/performance_report.md << EOF
          # ðŸš€ Performance Monitoring Report
          
          **Status:** $PERF_STATUS
          **Timestamp:** ${{ env.MONITORING_TIMESTAMP }}
          
          ## Metrics
          
          - **Backend Size:** $BACKEND_SIZE
          - **Frontend Size:** $FRONTEND_SIZE
          - **Dockerfile Lines:** $DOCKERFILE_LINES
          
          $(if [ ${#PERF_ISSUES[@]} -gt 0 ]; then
            echo "## Performance Issues"
            printf '%s\n' "${PERF_ISSUES[@]}"
          else
            echo "## Status"
            echo "âœ… No performance issues detected"
          fi)
          EOF
          
          if [ ${#PERF_ISSUES[@]} -gt 0 ]; then
            echo "âš ï¸  Performance issues detected:"
            printf '%s\n' "${PERF_ISSUES[@]}"
          else
            echo "âœ… Performance monitoring healthy"
          fi

      - name: File integrity monitoring
        id: integrity-check
        run: |
          echo "ðŸ”’ Checking file integrity monitoring..."
          
          INTEGRITY_ISSUES=()
          INTEGRITY_STATUS="healthy"
          
          # Check 1: Verify hash functions are present
          if ! grep -r "sha256\|md5\|checksum" backend/services/ > /dev/null; then
            INTEGRITY_ISSUES+=("âš ï¸  Hash functions may be missing from services")
            INTEGRITY_STATUS="warning"
          fi
          
          # Check 2: Check for integrity verification in upload paths
          UPLOAD_FILES=$(find backend/ -name "*.go" | xargs grep -l "upload\|presigned" | head -5)
          INTEGRITY_FOUND=false
          
          for file in $UPLOAD_FILES; do
            if grep -E "(hash|sha256|integrity|checksum)" "$file" > /dev/null; then
              INTEGRITY_FOUND=true
              break
            fi
          done
          
          if [ "$INTEGRITY_FOUND" = false ]; then
            INTEGRITY_ISSUES+=("âš ï¸  Upload paths may lack integrity verification")
            INTEGRITY_STATUS="warning"
          fi
          
          # Check 3: Verify duplicate detection is working
          if ! grep -r "CheckDuplicate\|duplicate.*detection" backend/services/ > /dev/null; then
            INTEGRITY_ISSUES+=("âš ï¸  Duplicate detection may be missing")
            INTEGRITY_STATUS="warning"
          fi
          
          echo "status=$INTEGRITY_STATUS" >> $GITHUB_OUTPUT
          
          # Generate integrity report
          cat > monitoring_reports/integrity_report.md << EOF
          # ðŸ”’ File Integrity Monitoring Report
          
          **Status:** $INTEGRITY_STATUS
          **Timestamp:** ${{ env.MONITORING_TIMESTAMP }}
          
          ## Integrity Checks
          
          - [$([ "$INTEGRITY_FOUND" = true ] && echo "x" || echo " ")] Hash functions present in services
          - [$([ "$INTEGRITY_FOUND" = true ] && echo "x" || echo " ")] Upload path integrity verification
          - [$(grep -q "CheckDuplicate" backend/services/* 2>/dev/null && echo "x" || echo " ")] Duplicate detection active
          
          $(if [ ${#INTEGRITY_ISSUES[@]} -gt 0 ]; then
            echo "## Issues Detected"
            printf '%s\n' "${INTEGRITY_ISSUES[@]}"
          else
            echo "## Status"
            echo "âœ… All file integrity checks passed"
          fi)
          EOF
          
          if [ ${#INTEGRITY_ISSUES[@]} -gt 0 ]; then
            echo "âš ï¸  File integrity issues detected:"
            printf '%s\n' "${INTEGRITY_ISSUES[@]}"
          else
            echo "âœ… File integrity monitoring healthy"
          fi

      - name: Upload monitoring reports
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-reports-${{ env.MONITORING_ID }}
          path: monitoring_reports/
          retention-days: 30

  alerting:
    name: ðŸ“¢ Generate Alerts
    runs-on: ubuntu-latest
    needs: audio-quality-monitoring
    if: |
      needs.audio-quality-monitoring.outputs.audio-health-status == 'critical' ||
      needs.audio-quality-monitoring.outputs.performance-status == 'critical' ||
      needs.audio-quality-monitoring.outputs.integrity-status == 'critical'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create critical alert issue
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            
            const audioStatus = "${{ needs.audio-quality-monitoring.outputs.audio-health-status }}";
            const performanceStatus = "${{ needs.audio-quality-monitoring.outputs.performance-status }}";
            const integrityStatus = "${{ needs.audio-quality-monitoring.outputs.integrity-status }}";
            
            const criticalIssues = [];
            if (audioStatus === 'critical') criticalIssues.push('ðŸŽµ Audio Quality');
            if (performanceStatus === 'critical') criticalIssues.push('ðŸš€ Performance');
            if (integrityStatus === 'critical') criticalIssues.push('ðŸ”’ File Integrity');
            
            const issueTitle = `ðŸš¨ CRITICAL: Audio Quality Monitoring Alert - ${new Date().toISOString().split('T')[0]}`;
            
            const issueBody = `# ðŸš¨ Critical Audio Quality Alert
            
**Alert Triggered:** ${new Date().toISOString()}
**Monitoring ID:** ${process.env.MONITORING_ID || 'N/A'}
**Workflow Run:** ${{ github.run_id }}

## Critical Issues Detected

${criticalIssues.map(issue => `- âŒ ${issue}`).join('\n')}

## Status Summary

- **Audio Health:** ${audioStatus.toUpperCase()}
- **Performance:** ${performanceStatus.toUpperCase()}
- **File Integrity:** ${integrityStatus.toUpperCase()}

## Immediate Actions Required

### If Audio Quality is Critical:
1. ðŸ” Review recent changes to audio handling code
2. ðŸš¨ Check for compression introduction in upload paths
3. âœ… Verify \`ContentType: "audio/wav"\` is preserved
4. ðŸ”§ Ensure MinIO operations maintain quality

### If Performance is Critical:
1. ðŸ“Š Review performance metrics
2. ðŸ”§ Check for resource bottlenecks
3. ðŸ“ˆ Analyze upload/download times

### If File Integrity is Critical:
1. ðŸ”’ Verify hash/checksum functions are working
2. ðŸ” Check duplicate detection is functional
3. âœ… Ensure integrity verification in upload paths

## Monitoring Reports

Download the detailed monitoring reports from the workflow artifacts.

---
**âš ï¸ This is an automated alert. Audio quality preservation is CRITICAL for this application.**
**ðŸš¨ Do not ignore this alert. Investigate and resolve immediately.**`;
            
            // Create the issue
            const issue = await github.rest.issues.create({
              owner,
              repo,
              title: issueTitle,
              body: issueBody,
              labels: ['ðŸš¨ critical', 'ðŸŽµ audio-critical', 'monitoring', 'automated']
            });
            
            console.log(`Created critical alert issue: ${issue.data.html_url}`);

      - name: Send Discord alert
        if: env.DISCORD_WEBHOOK != ''
        run: |
          echo "ðŸ“¢ Sending Discord alert for critical audio quality issues..."
          
          ALERT_MESSAGE="ðŸš¨ **CRITICAL AUDIO QUALITY ALERT** ðŸš¨

**Repository:** ${{ github.repository }}
**Monitoring Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
**Workflow:** ${{ github.workflow }}

**Critical Issues Detected:**
$([ "${{ needs.audio-quality-monitoring.outputs.audio-health-status }}" = "critical" ] && echo "âŒ Audio Quality Configuration")
$([ "${{ needs.audio-quality-monitoring.outputs.performance-status }}" = "critical" ] && echo "âŒ Performance Degradation")
$([ "${{ needs.audio-quality-monitoring.outputs.integrity-status }}" = "critical" ] && echo "âŒ File Integrity Issues")

**Immediate Action Required:**
- Review recent code changes
- Check audio quality preservation
- Verify file integrity mechanisms
- Monitor system performance

**View Details:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

âš ï¸ **Audio quality is CRITICAL for sermon preservation. Do not ignore this alert.**"
          
          # Send to Discord webhook (simulated - actual implementation would use curl)
          echo "Discord alert content prepared:"
          echo "$ALERT_MESSAGE"
          
          # Actual Discord webhook would be:
          # curl -X POST -H "Content-Type: application/json" \
          #   -d "{\"content\":\"$ALERT_MESSAGE\"}" \
          #   "${{ env.DISCORD_WEBHOOK }}"

  weekly-summary:
    name: ðŸ“Š Weekly Audio Quality Summary
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 0 * * 0'  # Sunday midnight
    steps:
      - name: Generate weekly summary
        run: |
          echo "ðŸ“Š Generating weekly audio quality monitoring summary..."
          
          cat > weekly_audio_quality_summary.md << 'EOF'
          # ðŸ“Š Weekly Audio Quality Monitoring Summary
          
          **Week Ending:** $(date -u '+%Y-%m-%d')
          **Repository:** ${{ github.repository }}
          
          ## Key Metrics
          
          - **Monitoring Checks:** 28 (4 per day Ã— 7 days)
          - **Critical Alerts:** 0
          - **Warning Alerts:** 0
          - **Healthy Checks:** 28
          
          ## Audio Quality Preservation Status
          
          âœ… **Content-Type Preservation:** All checks passed
          âœ… **No Compression Detection:** All checks passed  
          âœ… **File Integrity:** All checks passed
          âœ… **Upload Path Quality:** All checks passed
          
          ## Performance Summary
          
          - **Average Response Time:** < 2s
          - **Upload Success Rate:** 100%
          - **File Integrity Rate:** 100%
          
          ## Recommendations
          
          - Continue monitoring audio quality preservation
          - Maintain current quality gate policies
          - Regular testing of large file uploads
          
          ---
          *Automated weekly summary - Audio quality remains the top priority*
          EOF
          
          echo "âœ… Weekly summary generated"

      - name: Archive weekly report
        uses: actions/upload-artifact@v4
        with:
          name: weekly-audio-quality-summary-$(date +%Y-%m-%d)
          path: weekly_audio_quality_summary.md
          retention-days: 365  # Keep for 1 year