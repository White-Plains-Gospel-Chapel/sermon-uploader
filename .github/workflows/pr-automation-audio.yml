name: PR Automation with Audio Quality Focus

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  checks: write
  issues: write

jobs:
  label-pr:
    name: ðŸ·ï¸ Auto-label PR based on changes
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze changed files and apply labels
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            // Get list of changed files
            const files = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: number,
            });
            
            const changedFiles = files.data.map(f => f.filename);
            const labels = [];
            
            console.log('Changed files:', changedFiles);
            
            // Audio-critical file patterns
            const audioCriticalPatterns = [
              /backend\/services\/(minio|file_service|metadata).*\.go$/,
              /backend\/handlers\/(handlers|presigned).*\.go$/,
              /backend\/config\/config\.go$/,
              /frontend\/.*upload.*\.(ts|tsx|js|jsx)$/,
              /frontend\/.*audio.*\.(ts|tsx|js|jsx)$/,
            ];
            
            // Check for audio-critical changes
            const hasAudioCritical = changedFiles.some(file => 
              audioCriticalPatterns.some(pattern => pattern.test(file))
            );
            
            if (hasAudioCritical) {
              labels.push('ðŸŽµ audio-critical');
              labels.push('needs-thorough-review');
            }
            
            // Backend changes
            if (changedFiles.some(f => f.startsWith('backend/'))) {
              labels.push('backend');
              
              // Go-specific labels
              if (changedFiles.some(f => f.endsWith('.go'))) {
                labels.push('go');
              }
              
              // Service layer changes
              if (changedFiles.some(f => f.includes('services/'))) {
                labels.push('services');
              }
              
              // Handler changes
              if (changedFiles.some(f => f.includes('handlers/'))) {
                labels.push('api');
              }
            }
            
            // Frontend changes
            if (changedFiles.some(f => f.startsWith('frontend/'))) {
              labels.push('frontend');
              
              // TypeScript/React changes
              if (changedFiles.some(f => f.match(/\.(ts|tsx)$/))) {
                labels.push('typescript');
              }
              
              // Component changes
              if (changedFiles.some(f => f.includes('components/'))) {
                labels.push('ui-components');
              }
            }
            
            // Infrastructure changes
            if (changedFiles.some(f => f.match(/(docker|compose|Dockerfile)/))) {
              labels.push('infrastructure');
              labels.push('deployment');
            }
            
            // GitHub Actions/CI changes
            if (changedFiles.some(f => f.startsWith('.github/'))) {
              labels.push('github-actions');
              labels.push('ci-cd');
            }
            
            // Configuration changes
            if (changedFiles.some(f => f.match(/\.(yml|yaml|json|env)$/))) {
              labels.push('configuration');
            }
            
            // Documentation changes
            if (changedFiles.some(f => f.match(/\.(md|txt)$/))) {
              labels.push('documentation');
            }
            
            // Test changes
            if (changedFiles.some(f => f.match(/(test|spec)\./))) {
              labels.push('tests');
            }
            
            // Size-based labels
            const totalChanges = files.data.reduce((acc, f) => acc + f.changes, 0);
            if (totalChanges > 500) {
              labels.push('size/large');
              labels.push('needs-extra-review');
            } else if (totalChanges > 100) {
              labels.push('size/medium');
            } else {
              labels.push('size/small');
            }
            
            // Security-sensitive patterns
            const securityPatterns = [
              /auth/i,
              /password/i,
              /secret/i,
              /token/i,
              /credential/i,
              /security/i
            ];
            
            if (changedFiles.some(file => 
              securityPatterns.some(pattern => pattern.test(file))
            )) {
              labels.push('security');
              labels.push('needs-security-review');
            }
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: number,
                labels: labels,
              });
              
              console.log('Applied labels:', labels);
            }

  assign-reviewers:
    name: ðŸ” Assign reviewers for audio-critical changes
    runs-on: ubuntu-latest
    needs: label-pr
    if: contains(github.event.pull_request.labels.*.name, 'ðŸŽµ audio-critical')
    steps:
      - name: Assign audio quality reviewer
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            // For audio-critical changes, ensure primary maintainer reviews
            await github.rest.pulls.requestReviewers({
              owner,
              repo,
              pull_number: number,
              reviewers: ['greastern'], // Primary maintainer
            });
            
            // Add comment explaining the audio-critical review requirement
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: number,
              body: `ðŸŽµ **Audio Quality Review Required**
              
This PR contains changes to audio-critical code paths that could affect audio quality preservation.

**Critical Review Areas:**
- âœ… Verify no compression is introduced in upload paths
- âœ… Ensure \`ContentType: "audio/wav"\` is preserved
- âœ… Confirm MinIO operations maintain file integrity
- âœ… Check that presigned URLs don't alter audio data
- âœ… Validate any changes to metadata extraction don't affect audio

**Audio Quality Checklist:**
- [ ] Upload operations use \`ContentType: "audio/wav"\`
- [ ] No compression algorithms introduced (gzip, deflate, etc.)
- [ ] MinIO \`PutObject\` operations preserve original data
- [ ] Presigned URL generation doesn't include transformation
- [ ] File integrity verification is maintained

@greastern Please review carefully for audio quality preservation.`
            });

  check-audio-quality-requirements:
    name: ðŸŽµ Verify Audio Quality Requirements
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check PR description for audio quality checklist
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: number,
            });
            
            const prBody = pr.data.body || '';
            const hasAudioCriticalLabel = pr.data.labels.some(label => 
              label.name === 'ðŸŽµ audio-critical'
            );
            
            if (hasAudioCriticalLabel) {
              // Check if PR description includes audio quality checklist
              const requiredChecks = [
                'ContentType.*audio/wav',
                'compression.*algorithm',
                'file.*integrity',
                'presigned.*URL'
              ];
              
              const missingChecks = requiredChecks.filter(check => 
                !new RegExp(check, 'i').test(prBody)
              );
              
              if (missingChecks.length > 0) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: number,
                  body: `âš ï¸ **Audio Quality Checklist Missing**
                  
This PR is labeled as audio-critical but is missing required audio quality checklist items:

${missingChecks.map(check => `- ${check}`).join('\n')}

Please update your PR description to include the audio quality preservation checklist.`
                });
                
                core.setFailed('Audio quality checklist incomplete');
              }
            }

  block-dangerous-patterns:
    name: ðŸš« Block Dangerous Audio Patterns
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scan for prohibited audio modifications
        run: |
          echo "ðŸ” Scanning for prohibited audio quality modifications..."
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          
          # Dangerous patterns that could compromise audio quality
          DANGEROUS_PATTERNS=(
            "application/.*audio.*(?!wav)"
            "compress.*audio"
            "transform.*wav"
            "encode.*audio"
            "quality.*[0-9]+"
            "bitrate.*[0-9]+"
          )
          
          VIOLATIONS=()
          
          for pattern in "${DANGEROUS_PATTERNS[@]}"; do
            if echo "$CHANGED_FILES" | xargs grep -l -E "$pattern" 2>/dev/null | grep -v test | grep -v node_modules; then
              VIOLATIONS+=("Found dangerous pattern: $pattern")
            fi
          done
          
          # Check for MinIO compression options
          if echo "$CHANGED_FILES" | xargs grep -l "PutObjectOptions" | xargs grep -A10 -B5 "PutObjectOptions" | grep -E "(compress|encoding|transform)"; then
            VIOLATIONS+=("Found potential compression in MinIO operations")
          fi
          
          # Check for frontend file modifications
          if echo "$CHANGED_FILES" | grep -E "\.(ts|tsx|js|jsx)$" | xargs grep -l -E "(compress|transform|encode).*file" | grep -v test; then
            VIOLATIONS+=("Found potential file transformation in frontend")
          fi
          
          if [ ${#VIOLATIONS[@]} -gt 0 ]; then
            echo "ðŸš¨ DANGEROUS AUDIO QUALITY VIOLATIONS DETECTED:"
            printf '%s\n' "${VIOLATIONS[@]}"
            
            # Comment on PR
            gh pr comment ${{ github.event.number }} --body "ðŸš¨ **AUDIO QUALITY VIOLATION DETECTED**

The following dangerous patterns were found that could compromise audio quality:

$(printf '- %s\n' "${VIOLATIONS[@]}")

Please remove these patterns before the PR can be merged."
            
            exit 1
          else
            echo "âœ… No dangerous audio quality patterns detected"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  require-tests-for-audio-changes:
    name: ðŸ§ª Require Tests for Audio Changes
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'ðŸŽµ audio-critical')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for corresponding tests
        run: |
          echo "ðŸ§ª Checking for tests covering audio-critical changes..."
          
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          AUDIO_FILES=$(echo "$CHANGED_FILES" | grep -E "(minio|upload|presigned|metadata)" | grep -v test)
          TEST_FILES=$(echo "$CHANGED_FILES" | grep -E "test|spec")
          
          if [ -n "$AUDIO_FILES" ] && [ -z "$TEST_FILES" ]; then
            echo "âŒ Audio-critical changes detected but no test files modified"
            
            gh pr comment ${{ github.event.number }} --body "ðŸ§ª **Tests Required for Audio-Critical Changes**

This PR modifies audio-critical files but doesn't include corresponding tests:

$(echo "$AUDIO_FILES" | sed 's/^/- /')

Please add tests that verify:
- File integrity preservation
- Correct content type handling  
- No compression introduction
- Upload/download cycle integrity"
            
            exit 1
          else
            echo "âœ… Tests found for audio-critical changes"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  size-based-review:
    name: ðŸ“ Size-based Review Requirements
    runs-on: ubuntu-latest
    steps:
      - name: Check PR size and enforce review requirements
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            const files = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: number,
            });
            
            const totalChanges = files.data.reduce((acc, f) => acc + f.changes, 0);
            const fileCount = files.data.length;
            
            let reviewersNeeded = 1;
            let message = '';
            
            if (totalChanges > 1000 || fileCount > 20) {
              reviewersNeeded = 2;
              message = `ðŸ“ **Large PR Detected** (${totalChanges} changes, ${fileCount} files)
              
This PR requires review from at least **2 reviewers** due to its size.
              
**Review Guidelines:**
- Focus on architectural changes
- Verify backward compatibility
- Check for potential performance impacts
- Ensure comprehensive testing`;
              
            } else if (totalChanges > 500 || fileCount > 10) {
              message = `ðŸ“ **Medium PR Detected** (${totalChanges} changes, ${fileCount} files)
              
Please ensure thorough review of:
- Core functionality changes
- API modifications
- Configuration updates`;
            }
            
            if (message) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: message,
              });
            }

  auto-merge-check:
    name: ðŸ¤– Auto-merge Eligibility Check
    runs-on: ubuntu-latest
    if: |
      github.event.review.state == 'approved' ||
      (github.event.action == 'synchronize' && contains(github.event.pull_request.labels.*.name, 'auto-merge'))
    steps:
      - name: Check auto-merge eligibility
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo, number } = context.issue;
            
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: number,
            });
            
            // Never auto-merge audio-critical PRs
            const hasAudioCriticalLabel = pr.data.labels.some(label => 
              label.name === 'ðŸŽµ audio-critical'
            );
            
            if (hasAudioCriticalLabel) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: `ðŸŽµ **Auto-merge Blocked: Audio-Critical Changes**
                
This PR contains audio-critical changes and cannot be auto-merged.
Manual review and explicit approval is required to ensure audio quality preservation.`,
              });
              
              // Remove auto-merge label if present
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: number,
                  name: 'auto-merge',
                });
              } catch (error) {
                // Label might not exist, that's okay
              }
              
              return;
            }
            
            // Check other auto-merge criteria
            const labels = pr.data.labels.map(label => label.name);
            const canAutoMerge = (
              !labels.includes('needs-thorough-review') &&
              !labels.includes('size/large') &&
              !labels.includes('security') &&
              labels.includes('size/small')
            );
            
            if (canAutoMerge && !labels.includes('auto-merge')) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: number,
                labels: ['auto-merge'],
              });
            }