name: Comprehensive PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]

env:
  GO_VERSION: "1.21"
  NODE_VERSION: "20"
  COVERAGE_THRESHOLD: 80
  DOCKER_BUILDKIT: 1

jobs:
  # Job 1: PR Analysis and Auto-labeling
  pr-analysis:
    name: PR Analysis & Labeling
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    outputs:
      pr-size: ${{ steps.size.outputs.size }}
      has-backend: ${{ steps.analysis.outputs.has-backend }}
      has-frontend: ${{ steps.analysis.outputs.has-frontend }}
      has-docker: ${{ steps.analysis.outputs.has-docker }}
      has-docs: ${{ steps.analysis.outputs.has-docs }}
      has-tests: ${{ steps.analysis.outputs.has-tests }}
      is-breaking: ${{ steps.analysis.outputs.is-breaking }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR size and changes
        id: size
        run: |
          # Calculate lines changed
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}
          
          ADDITIONS=$(git diff --numstat $BASE_SHA..$HEAD_SHA | awk '{sum += $1} END {print sum}')
          DELETIONS=$(git diff --numstat $BASE_SHA..$HEAD_SHA | awk '{sum += $2} END {print sum}')
          TOTAL_CHANGES=$((ADDITIONS + DELETIONS))
          
          echo "Total changes: $TOTAL_CHANGES lines"
          
          if [ $TOTAL_CHANGES -lt 10 ]; then
            SIZE="XS"
          elif [ $TOTAL_CHANGES -lt 50 ]; then
            SIZE="S"
          elif [ $TOTAL_CHANGES -lt 200 ]; then
            SIZE="M"
          elif [ $TOTAL_CHANGES -lt 500 ]; then
            SIZE="L"
          else
            SIZE="XL"
          fi
          
          echo "size=$SIZE" >> $GITHUB_OUTPUT

      - name: Analyze changed files and components
        id: analysis
        run: |
          BASE_SHA=${{ github.event.pull_request.base.sha }}
          HEAD_SHA=${{ github.event.pull_request.head.sha }}
          
          CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA)
          
          # Initialize flags
          HAS_BACKEND=false
          HAS_FRONTEND=false
          HAS_DOCKER=false
          HAS_DOCS=false
          HAS_TESTS=false
          IS_BREAKING=false
          
          echo "Analyzing changed files..."
          echo "$CHANGED_FILES" | while IFS= read -r file; do
            echo "  $file"
          done
          
          # Check for backend changes
          if echo "$CHANGED_FILES" | grep -E "^backend/.*\.(go|mod|sum)$" > /dev/null; then
            HAS_BACKEND=true
            echo "has-backend=true" >> $GITHUB_OUTPUT
          else
            echo "has-backend=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for frontend changes
          if echo "$CHANGED_FILES" | grep -E "^frontend/.*\.(js|ts|tsx|jsx|json)$" > /dev/null; then
            HAS_FRONTEND=true
            echo "has-frontend=true" >> $GITHUB_OUTPUT
          else
            echo "has-frontend=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for Docker changes
          if echo "$CHANGED_FILES" | grep -E "(Dockerfile|docker-compose|\.dockerignore)" > /dev/null; then
            HAS_DOCKER=true
            echo "has-docker=true" >> $GITHUB_OUTPUT
          else
            echo "has-docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for documentation changes
          if echo "$CHANGED_FILES" | grep -E "\.(md|txt|rst)$" > /dev/null; then
            HAS_DOCS=true
            echo "has-docs=true" >> $GITHUB_OUTPUT
          else
            echo "has-docs=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for test changes
          if echo "$CHANGED_FILES" | grep -E "(_test\.go|\.test\.|spec\.|test/)" > /dev/null; then
            HAS_TESTS=true
            echo "has-tests=true" >> $GITHUB_OUTPUT
          else
            echo "has-tests=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for breaking changes (API changes, config changes, etc.)
          if echo "$CHANGED_FILES" | grep -E "(main\.go|config/|handlers/.*\.go|docker-compose.*\.yml)" > /dev/null; then
            IS_BREAKING=true
            echo "is-breaking=true" >> $GITHUB_OUTPUT
          else
            echo "is-breaking=false" >> $GITHUB_OUTPUT
          fi

      - name: Apply labels based on analysis
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          # Size labels
          gh pr edit $PR_NUMBER --add-label "size/${{ steps.size.outputs.size }}"
          
          # Component labels
          if [ "${{ steps.analysis.outputs.has-backend }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "backend"
          fi
          
          if [ "${{ steps.analysis.outputs.has-frontend }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "frontend"
          fi
          
          if [ "${{ steps.analysis.outputs.has-docker }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "docker"
          fi
          
          if [ "${{ steps.analysis.outputs.has-docs }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "documentation"
          fi
          
          if [ "${{ steps.analysis.outputs.has-tests }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "tests"
          fi
          
          if [ "${{ steps.analysis.outputs.is-breaking }}" = "true" ]; then
            gh pr edit $PR_NUMBER --add-label "breaking-change"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 2: Backend Testing & Quality
  backend-quality:
    name: Backend Quality & Testing
    runs-on: ubuntu-latest
    needs: pr-analysis
    if: needs.pr-analysis.outputs.has-backend == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('backend/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        working-directory: backend
        run: go mod download

      - name: Run go fmt
        working-directory: backend
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Code is not properly formatted. Please run 'go fmt ./...'"
            gofmt -s -l .
            exit 1
          fi

      - name: Run go vet
        working-directory: backend
        run: go vet ./...

      - name: Install golangci-lint
        run: |
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.54.2

      - name: Run golangci-lint
        working-directory: backend
        run: $(go env GOPATH)/bin/golangci-lint run --timeout=5m

      - name: Run tests with coverage
        working-directory: backend
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
          go tool cover -html=coverage.out -o coverage.html
          
          # Calculate coverage percentage
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
          echo "Coverage: ${COVERAGE}%"
          
          # Check if coverage meets threshold
          if (( $(echo "$COVERAGE < ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "::error::Coverage ${COVERAGE}% is below threshold ${{ env.COVERAGE_THRESHOLD }}%"
            exit 1
          fi
          
          echo "COVERAGE_PERCENT=$COVERAGE" >> $GITHUB_ENV

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage
          path: |
            backend/coverage.out
            backend/coverage.html

      - name: Build backend
        working-directory: backend
        run: |
          go build -v -o sermon-uploader ./
          
          # Test that binary runs
          ./sermon-uploader --version || echo "Binary created successfully"

  # Job 3: Frontend Testing & Quality
  frontend-quality:
    name: Frontend Quality & Testing
    runs-on: ubuntu-latest
    needs: pr-analysis
    if: needs.pr-analysis.outputs.has-frontend == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Run ESLint
        working-directory: frontend
        run: npm run lint

      - name: Run TypeScript type check
        working-directory: frontend
        run: npm run type-check

      - name: Run tests (if they exist)
        working-directory: frontend
        run: |
          # Check if test script exists
          if npm run --silent 2>&1 | grep -q "test"; then
            npm run test -- --coverage --watchAll=false
          else
            echo "No tests configured yet"
          fi

      - name: Build frontend
        working-directory: frontend
        run: |
          npm run build
          
          # Check build output
          if [ ! -d ".next" ]; then
            echo "::error::Frontend build failed - .next directory not found"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/.next

  # Job 4: Security Scanning
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: pr-analysis
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Scan Go dependencies
        if: needs.pr-analysis.outputs.has-backend == 'true'
        working-directory: backend
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

      - name: Scan Node.js dependencies
        if: needs.pr-analysis.outputs.has-frontend == 'true'
        working-directory: frontend
        run: |
          npm audit --audit-level=high
          
          # Check for known vulnerabilities
          npx audit-ci --high

  # Job 5: Docker Build & Security
  docker-validation:
    name: Docker Build & Security
    runs-on: ubuntu-latest
    needs: pr-analysis
    if: needs.pr-analysis.outputs.has-docker == 'true' || needs.pr-analysis.outputs.has-backend == 'true' || needs.pr-analysis.outputs.has-frontend == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test images
        run: |
          # Build images but don't push
          if [ -f "docker-compose.yml" ]; then
            docker-compose build
          elif [ -f "Dockerfile" ]; then
            docker build -t test-image .
          fi

      - name: Scan Docker images for vulnerabilities
        run: |
          # Get list of built images
          IMAGES=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep -v "REPOSITORY" | head -5)
          
          for IMAGE in $IMAGES; do
            if [ "$IMAGE" != "<none>:<none>" ]; then
              echo "Scanning $IMAGE..."
              docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL $IMAGE
            fi
          done

  # Job 6: Integration Testing
  integration-tests:
    name: Integration Testing
    runs-on: ubuntu-latest
    needs: [pr-analysis, backend-quality, frontend-quality]
    if: always() && (needs.backend-quality.result == 'success' || needs.frontend-quality.result == 'success')
    
    services:
      minio:
        image: minio/minio
        env:
          MINIO_ACCESS_KEY: testkey
          MINIO_SECRET_KEY: testsecret
        ports:
          - 9000:9000
        options: >-
          --health-cmd "curl -f http://localhost:9000/minio/health/live"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up test environment
        run: |
          # Create test .env file
          cat > .env.test << EOF
          MINIO_ENDPOINT=localhost:9000
          MINIO_ACCESS_KEY=testkey
          MINIO_SECRET_KEY=testsecret
          MINIO_BUCKET_NAME=test-sermons
          MINIO_USE_SSL=false
          DISCORD_WEBHOOK_URL=https://hooks.slack.com/test
          EOF

      - name: Set up Go for backend tests
        if: needs.pr-analysis.outputs.has-backend == 'true'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run backend integration tests
        if: needs.pr-analysis.outputs.has-backend == 'true'
        working-directory: backend
        run: |
          # Install MinIO client for testing
          curl -O https://dl.min.io/client/mc/release/linux-amd64/mc
          chmod +x mc
          ./mc alias set test http://localhost:9000 testkey testsecret
          ./mc mb test/test-sermons || true
          
          # Run integration tests
          go test -v -tags=integration ./...

      - name: Test API endpoints
        run: |
          # Start the application in background
          cd backend
          go build -o sermon-uploader
          ./sermon-uploader &
          APP_PID=$!
          
          # Wait for app to start
          sleep 10
          
          # Test health endpoints
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/api/upload/presigned || true
          
          # Cleanup
          kill $APP_PID

  # Job 7: Performance Testing
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: needs.pr-analysis.outputs.is-breaking == 'true' || contains(github.event.pull_request.title, '[perf]')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run load tests
        run: |
          # Install k6 for load testing
          curl -s https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz | tar xz
          sudo mv k6-v0.46.0-linux-amd64/k6 /usr/local/bin/
          
          # Create basic load test
          cat > loadtest.js << 'EOF'
          import http from 'k6/http';
          import { check } from 'k6';
          
          export let options = {
            vus: 10, // 10 virtual users
            duration: '30s',
          };
          
          export default function () {
            let response = http.get('http://localhost:8080/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
          }
          EOF
          
          # Start app and run test
          cd backend
          go build -o sermon-uploader
          ./sermon-uploader &
          sleep 5
          k6 run ../loadtest.js

  # Job 8: Final Validation Summary
  validation-summary:
    name: Validation Summary
    runs-on: ubuntu-latest
    needs: [pr-analysis, backend-quality, frontend-quality, security-scan, docker-validation, integration-tests]
    if: always()
    
    steps:
      - name: Generate validation summary
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          
          # Collect results
          BACKEND_STATUS="${{ needs.backend-quality.result }}"
          FRONTEND_STATUS="${{ needs.frontend-quality.result }}"
          SECURITY_STATUS="${{ needs.security-scan.result }}"
          DOCKER_STATUS="${{ needs.docker-validation.result }}"
          INTEGRATION_STATUS="${{ needs.integration-tests.result }}"
          
          # Determine overall status
          OVERALL_STATUS="âœ… PASSED"
          if [[ "$BACKEND_STATUS" == "failure" ]] || [[ "$FRONTEND_STATUS" == "failure" ]] || [[ "$SECURITY_STATUS" == "failure" ]] || [[ "$DOCKER_STATUS" == "failure" ]] || [[ "$INTEGRATION_STATUS" == "failure" ]]; then
            OVERALL_STATUS="âŒ FAILED"
          fi
          
          # Create summary comment
          cat > summary.md << EOF
          ## ðŸ” PR Validation Summary
          
          **Overall Status:** $OVERALL_STATUS
          **PR Size:** ${{ needs.pr-analysis.outputs.pr-size }}
          
          ### Component Analysis
          - **Backend Changes:** ${{ needs.pr-analysis.outputs.has-backend == 'true' && 'âœ… Detected' || 'âšª None' }}
          - **Frontend Changes:** ${{ needs.pr-analysis.outputs.has-frontend == 'true' && 'âœ… Detected' || 'âšª None' }}
          - **Docker Changes:** ${{ needs.pr-analysis.outputs.has-docker == 'true' && 'âœ… Detected' || 'âšª None' }}
          - **Breaking Changes:** ${{ needs.pr-analysis.outputs.is-breaking == 'true' && 'âš ï¸ Detected' || 'âšª None' }}
          
          ### Quality Gates
          | Check | Status | Details |
          |-------|--------|---------|
          | Backend Quality | ${{ needs.backend-quality.result == 'success' && 'âœ… PASSED' || needs.backend-quality.result == 'failure' && 'âŒ FAILED' || 'âšª SKIPPED' }} | Code formatting, linting, tests |
          | Frontend Quality | ${{ needs.frontend-quality.result == 'success' && 'âœ… PASSED' || needs.frontend-quality.result == 'failure' && 'âŒ FAILED' || 'âšª SKIPPED' }} | TypeScript, ESLint, build |
          | Security Scan | ${{ needs.security-scan.result == 'success' && 'âœ… PASSED' || needs.security-scan.result == 'failure' && 'âŒ FAILED' || 'âšª SKIPPED' }} | Vulnerability scanning |
          | Docker Validation | ${{ needs.docker-validation.result == 'success' && 'âœ… PASSED' || needs.docker-validation.result == 'failure' && 'âŒ FAILED' || 'âšª SKIPPED' }} | Image builds, security |
          | Integration Tests | ${{ needs.integration-tests.result == 'success' && 'âœ… PASSED' || needs.integration-tests.result == 'failure' && 'âŒ FAILED' || 'âšª SKIPPED' }} | End-to-end functionality |
          
          ### Next Steps
          $( [[ "$OVERALL_STATUS" == "âœ… PASSED" ]] && echo "âœ… All checks passed! PR is ready for review." || echo "âŒ Some checks failed. Please review the failed jobs and fix issues." )
          
          ---
          <sub>Automated validation by GitHub Actions</sub>
          EOF
          
          gh pr comment $PR_NUMBER --body-file summary.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set status check
        run: |
          # This will be used by branch protection rules
          if [[ "${{ needs.backend-quality.result }}" == "failure" ]] || [[ "${{ needs.frontend-quality.result }}" == "failure" ]] || [[ "${{ needs.security-scan.result }}" == "failure" ]] || [[ "${{ needs.docker-validation.result }}" == "failure" ]] || [[ "${{ needs.integration-tests.result }}" == "failure" ]]; then
            echo "Some quality gates failed"
            exit 1
          fi
          echo "All quality gates passed"