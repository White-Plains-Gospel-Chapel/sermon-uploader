package main

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/signal"
	"runtime"
	"syscall"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/joho/godotenv"
	
	"sermon-uploader/handlers"
	"sermon-uploader/pkg/logging"
	"sermon-uploader/services"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		// Use fallback logging until logger is initialized
		fmt.Fprintf(os.Stderr, "Warning: .env file not found: %v\n", err)
	}
	
	// Initialize structured logger
	logConfig := logging.LoadConfigFromEnv()
	logger, err := logging.New("sermon-uploader", logConfig)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
		os.Exit(1)
	}
	
	// Set as default logger for packages that use slog.Default()
	slog.SetDefault(logger.Logger)
	
	// Log startup
	logger.Info("ðŸš€ Starting Sermon Uploader Service",
		slog.String("version", "1.0.0"),
		slog.String("go_version", runtime.Version()),
		slog.Int("cpu_cores", runtime.NumCPU()),
	)
	
	// Apply Pi optimizations
	applyPiOptimizations(logger)
	
	// Initialize configuration
	cfg := loadConfig(logger)
	
	// Initialize services
	ctx := context.Background()
	
	// Initialize MinIO service with structured logging
	minioLogger := logger.ForMinIO(cfg.MinioBucket)
	minioService, err := services.NewMinIOServiceV2(ctx, services.MinIOConfig{
		Endpoint:        cfg.MinioEndpoint,
		AccessKeyID:     cfg.MinioAccessKey,
		SecretAccessKey: cfg.MinioSecretKey,
		UseSSL:          cfg.MinioUseSSL,
		BucketName:      cfg.MinioBucket,
		Logger:          minioLogger,
	})
	if err != nil {
		logger.Error("failed to initialize MinIO service",
			slog.Any("error", logging.ErrMinIOConnection("initialization failed", err)),
		)
		os.Exit(1)
	}
	
	logger.Info("âœ… MinIO connection successful",
		slog.String("endpoint", cfg.MinioEndpoint),
		slog.String("bucket", cfg.MinioBucket),
	)
	
	// Initialize WebSocket hub with structured logging
	wsHub := services.NewWebSocketHub(logger.ForWebSocket("hub"))
	go wsHub.Run()
	
	// Initialize Discord service with structured logging
	discordService := services.NewDiscordService(cfg.DiscordWebhookURL, logger.ForDiscord())
	
	// Create Fiber app with structured logging
	app := fiber.New(fiber.Config{
		ErrorHandler: logging.ErrorHandler(logger),
		BodyLimit:    cfg.MaxFileSize,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
	})
	
	// Add middleware
	app.Use(logging.RecoveryMiddleware(logger))
	app.Use(logging.FiberMiddleware(logger))
	app.Use(cors.New(cors.Config{
		AllowOrigins:     cfg.AllowedOrigins,
		AllowMethods:     "GET,POST,PUT,DELETE,OPTIONS",
		AllowHeaders:     "Origin, Content-Type, Accept, Authorization, X-Correlation-ID, X-Request-ID",
		AllowCredentials: true,
	}))
	
	// Initialize handlers with services
	handlerDeps := handlers.Dependencies{
		MinIO:   minioService,
		WSHub:   wsHub,
		Discord: discordService,
		Logger:  logger,
	}
	
	// Setup routes
	setupRoutes(app, handlerDeps, logger)
	
	// Graceful shutdown
	go gracefulShutdown(app, logger)
	
	// Start server
	port := cfg.ServerPort
	logger.Info("ðŸ”§ Server starting",
		slog.String("port", port),
		slog.String("environment", cfg.Environment),
	)
	
	if err := app.Listen(":" + port); err != nil {
		logger.Error("server failed to start",
			slog.Any("error", err),
			slog.String("port", port),
		)
		os.Exit(1)
	}
}

func applyPiOptimizations(logger *logging.SermonLogger) {
	// Detect if running on Raspberry Pi
	if runtime.GOARCH == "arm" || runtime.GOARCH == "arm64" {
		logger.Info("ðŸ”§ Detected ARM architecture, applying Pi optimizations")
		
		// Set GOMAXPROCS to CPU count
		cpuCount := runtime.NumCPU()
		maxProcs := runtime.GOMAXPROCS(cpuCount)
		logger.Info("Pi optimization: GOMAXPROCS configured",
			slog.Int("cpu_cores", cpuCount),
			slog.Int("max_procs", maxProcs),
		)
		
		// Force garbage collection to free memory
		runtime.GC()
		
		// Get memory stats
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		
		logger.Info("Pi optimization: Memory status",
			slog.Uint64("alloc_mb", m.Alloc/1024/1024),
			slog.Uint64("sys_mb", m.Sys/1024/1024),
			slog.Uint32("num_gc", m.NumGC),
		)
	}
}

type Config struct {
	Environment       string
	ServerPort        string
	MinioEndpoint     string
	MinioAccessKey    string
	MinioSecretKey    string
	MinioUseSSL       bool
	MinioBucket       string
	DiscordWebhookURL string
	MaxFileSize       int
	AllowedOrigins    string
}

func loadConfig(logger *logging.SermonLogger) *Config {
	cfg := &Config{
		Environment:       getEnvDefault("ENVIRONMENT", "development"),
		ServerPort:        getEnvDefault("PORT", "3001"),
		MinioEndpoint:     getEnvDefault("MINIO_ENDPOINT", "localhost:9000"),
		MinioAccessKey:    os.Getenv("MINIO_ACCESS_KEY"),
		MinioSecretKey:    os.Getenv("MINIO_SECRET_KEY"),
		MinioUseSSL:       getEnvDefault("MINIO_USE_SSL", "false") == "true",
		MinioBucket:       getEnvDefault("MINIO_BUCKET_NAME", "sermons"),
		DiscordWebhookURL: os.Getenv("DISCORD_WEBHOOK_URL"),
		MaxFileSize:       5 * 1024 * 1024 * 1024, // 5GB
		AllowedOrigins:    getEnvDefault("ALLOWED_ORIGINS", "*"),
	}
	
	// Validate required configuration
	if cfg.MinioAccessKey == "" || cfg.MinioSecretKey == "" {
		logger.Error("MinIO credentials not configured",
			slog.Any("error", logging.ErrValidation("configuration", "MINIO_ACCESS_KEY and MINIO_SECRET_KEY are required")),
		)
		os.Exit(1)
	}
	
	logger.Debug("configuration loaded",
		slog.String("environment", cfg.Environment),
		slog.String("minio_endpoint", cfg.MinioEndpoint),
		slog.String("bucket", cfg.MinioBucket),
	)
	
	return cfg
}

func setupRoutes(app *fiber.App, deps handlers.Dependencies, logger *logging.SermonLogger) {
	// Health check
	app.Get("/health", func(c *fiber.Ctx) error {
		reqLogger := logging.GetLogger(c)
		reqLogger.Debug("health check requested")
		return c.JSON(fiber.Map{
			"status": "healthy",
			"time":   time.Now().Format(time.RFC3339),
		})
	})
	
	// API routes
	api := app.Group("/api")
	
	// Upload routes
	api.Post("/upload", deps.HandleUpload)
	api.Post("/upload/chunk", deps.HandleChunkUpload)
	api.Get("/upload/presigned", deps.HandlePresignedURL)
	
	// WebSocket
	api.Get("/ws", deps.HandleWebSocket)
	
	// File operations
	api.Get("/files", deps.ListFiles)
	api.Delete("/files/:filename", deps.DeleteFile)
	api.Get("/files/:filename/metadata", deps.GetFileMetadata)
	
	logger.Info("routes configured",
		slog.Int("route_count", 8),
	)
}

func gracefulShutdown(app *fiber.App, logger *logging.SermonLogger) {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	
	<-quit
	
	logger.Info("ðŸ›‘ Shutting down server...")
	
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := app.ShutdownWithContext(ctx); err != nil {
		logger.Error("server forced to shutdown",
			slog.Any("error", err),
		)
	}
	
	logger.Info("âœ… Server gracefully stopped")
}

func getEnvDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}